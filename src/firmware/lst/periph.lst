C51 COMPILER V9.51   PERIPH                                                                05/21/2013 06:46:35 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE PERIPH
OBJECT MODULE PLACED IN .\bin\periph.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE src\periph.c OMF2 PRINT(.\lst\periph.lst) TABS(2) OBJECT(.\bin\periph.obj)

line level    source

   1          //-----------------------------------------------------------------------------
   2          //   File:      periph.c
   3          //   Contents:  Hooks required to implement USB peripheral function.
   4          //
   5          // $Archive: /USB/Target/Fw/lp/periph.c $
   6          // $Date: 3/23/05 3:03p $
   7          // $Revision: 3 $
   8          //
   9          //
  10          //-----------------------------------------------------------------------------
  11          // Copyright 2003, Cypress Semiconductor Corporation
  12          //
  13          // This software is owned by Cypress Semiconductor Corporation (Cypress) and is
  14          // protected by United States copyright laws and international treaty provisions. Cypress
  15          // hereby grants to Licensee a personal, non-exclusive, non-transferable license to copy,
  16          // use, modify, create derivative works of, and compile the Cypress Source Code and
  17          // derivative works for the sole purpose of creating custom software in support of Licensee
  18          // product ("Licensee Product") to be used only in conjunction with a Cypress integrated
  19          // circuit. Any reproduction, modification, translation, compilation, or representation of this
  20          // software except as specified above is prohibited without the express written permission of
  21          // Cypress.
  22          //
  23          // Disclaimer: Cypress makes no warranty of any kind, express or implied, with regard to
  24          // this material, including, but not limited to, the implied warranties of merchantability and
  25          // fitness for a particular purpose. Cypress reserves the right to make changes without
  26          // further notice to the materials described herein. Cypress does not assume any liability
  27          // arising out of the application or use of any product or circuit described herein. Cypress’
  28          // products described herein are not authorized for use as components in life-support
  29          // devices.
  30          //
  31          // This software is protected by and subject to worldwide patent coverage, including U.S.
  32          // and foreign patents. Use may be limited by and subject to the Cypress Software License
  33          // Agreement.
  34          //-----------------------------------------------------------------------------
  35          #pragma NOIV               // Do not generate interrupt vectors
  36          
  37          #include "GPSRx.h"
  38          
  39          extern BOOL   GotSUD;         // Received setup data flag
  40          extern BOOL   Sleep;
  41          extern BOOL   Rwuen;
  42          extern BOOL   Selfpwr;
  43          
  44          BYTE   Configuration;      // Current configuration
  45          BYTE   AlternateSetting;   // Alternate settings
  46          
  47          //-----------------------------------------------------------------------------
  48          // Task Dispatcher hooks
  49          //   The following hooks are called by the task dispatcher.
  50          //-----------------------------------------------------------------------------
  51          
  52          void TD_Init(void)             // Called once at startup
  53          {
  54   1        // set the CPU clock to 48MHz
  55   1        CPUCS = ((CPUCS & ~bmCLKSPD) | bmCLKSPD1);
C51 COMPILER V9.51   PERIPH                                                                05/21/2013 06:46:35 PAGE 2   

  56   1        SYNCDELAY;
  57   1      
  58   1        IFCONFIG = 0x13;          // use IFCLK pin driven by external logic (5MHz to 48MHz)
  59   1                                  // use slave FIFO interface pins driven sync by external master
  60   1        SYNCDELAY;
  61   1        
  62   1        REVCTL = 0x03;            // REVCTL.0 and REVCTL.1 set to 1
  63   1        SYNCDELAY;
  64   1          
  65   1        EP2CFG = 0xD8;            // EP2 enabled
  66   1                                  // direction IN (dev > host)
  67   1                                  // type isochronous
  68   1                                  // size 1024 bytes
  69   1                                  // quad buffering
  70   1        SYNCDELAY;
  71   1        
  72   1        EP2ISOINPKTS = 0x83;
  73   1        SYNCDELAY;
  74   1        
  75   1        EP4CFG &= 0x7F;           // EP4 disabled
  76   1        SYNCDELAY;
  77   1        
  78   1        EP6CFG &= 0x7F;           // EP6 disabled
  79   1        SYNCDELAY;
  80   1        
  81   1        EP8CFG &= 0x7F;           // EP8 disabled
  82   1        SYNCDELAY;
  83   1        
  84   1        FIFORESET = 0x80;         // reset all FIFOs
  85   1        SYNCDELAY;
  86   1        
  87   1        FIFORESET = 0x82;
  88   1        SYNCDELAY;
  89   1        
  90   1        FIFORESET = 0x84;
  91   1        SYNCDELAY;
  92   1        
  93   1        FIFORESET = 0x86;
  94   1        SYNCDELAY;
  95   1        
  96   1        FIFORESET = 0x88;
  97   1        SYNCDELAY;
  98   1        
  99   1        FIFORESET = 0x00;
 100   1        SYNCDELAY;
 101   1        
 102   1        EP2FIFOCFG = 0x0C;      // this defines the external interface to be the following:
 103   1                                // this lets the EZ-USB auto commit IN packets, gives the
 104   1                                // ability to send zero length packets,
 105   1                                // and sets the slave FIFO data interface to 8-bits
 106   1        
 107   1        PINFLAGSAB = 0x00;      // defines FLAGA as prog-level flag, pointed to by FIFOADR[1:0]
 108   1        SYNCDELAY;              // FLAGB as full flag, as pointed to by FIFOADR[1:0]
 109   1        
 110   1        PINFLAGSCD = 0x00;      // FLAGC as empty flag, as pointed to by FIFOADR[1:0]
 111   1                                // won't generally need FLAGD
 112   1        
 113   1        PORTACFG = 0x00;        // used PA7/FLAGD as a port pin, not as a FIFO flag
 114   1        SYNCDELAY;
 115   1        
 116   1        FIFOPINPOLAR = 0x04;    // set all slave FIFO interface pins as active low
 117   1        SYNCDELAY;
C51 COMPILER V9.51   PERIPH                                                                05/21/2013 06:46:35 PAGE 3   

 118   1        
 119   1        EP2AUTOINLENH = 0x04;   // EZ-USB automatically commits data in 1024-byte chunks
 120   1        SYNCDELAY;
 121   1        
 122   1        EP2AUTOINLENL = 0x00;
 123   1        SYNCDELAY;
 124   1        
 125   1        EP2FIFOPFH = 0x80;      // you can define the programmable flag (FLAGA)
 126   1        SYNCDELAY;              // to be active at the level you wish
 127   1        
 128   1        EP2FIFOPFL = 0x00;
 129   1        
 130   1        BREAKPT &= ~bmBPEN;      // to see BKPT LED go out TGE
 131   1      }
 132          
 133          void TD_Poll(void)             // Called repeatedly while the device is idle
 134          {
 135   1      }
 136          
 137          BOOL TD_Suspend(void)          // Called before the device goes into suspend mode
 138          {
 139   1         return(TRUE);
 140   1      }
 141          
 142          BOOL TD_Resume(void)          // Called after the device resumes
 143          {
 144   1         return(TRUE);
 145   1      }
 146          
 147          //-----------------------------------------------------------------------------
 148          // SPI interface
 149          //-----------------------------------------------------------------------------
 150          
 151          void SPI_Init()
 152          {
 153   1        OEA |= 0x0B;    // Port A config for SPI
 154   1                        // PA0 = MOSI 
 155   1                        // PA1 = SPI_CLK
 156   1                        // PA3 = SPI_SS
 157   1        SPI_SS = 1;
 158   1        SPI_CLK = 0;
 159   1        MOSI = 0;
 160   1      }
 161          
 162          void SPI_Begin()
 163          {
 164   1        SPI_CLK = 0;
 165   1        MOSI = 0;
 166   1        SPI_SS = 0;
 167   1        SPI_Delay(20);
 168   1      }
 169          
 170          void SPI_End()
 171          {
 172   1        SPI_Delay(20);
 173   1        SPI_SS = 1;
 174   1        SPI_CLK = 0;
 175   1        MOSI = 0;
 176   1      }
 177          
 178          void SPI_ByteWrite(unsigned char byte)
 179          {
C51 COMPILER V9.51   PERIPH                                                                05/21/2013 06:46:35 PAGE 4   

 180   1        unsigned char i;
 181   1        for(i = 0; i < 8; i++) // Loop through each bit
 182   1        {
 183   2          MOSI = (byte & 0x80) ? 1 : 0;
 184   2          
 185   2          SPI_Delay(20);
 186   2          SPI_CLK = 1;
 187   2          
 188   2          SPI_Delay(20);
 189   2          SPI_CLK = 0;
 190   2          
 191   2          byte = byte << 1;
 192   2        }
 193   1      }
 194          
 195          void SPI_Delay(unsigned char time)
 196          {
 197   1        while(time-- != 0); 
 198   1      }
 199          
 200          //-----------------------------------------------------------------------------
 201          // Device Request hooks
 202          //   The following hooks are called by the end point 0 device request parser.
 203          //-----------------------------------------------------------------------------
 204          
 205          BOOL DR_GetDescriptor(void)
 206          {
 207   1         return(TRUE);
 208   1      }
 209          
 210          BOOL DR_SetConfiguration(void)   // Called when a Set Configuration command is received
 211          {
 212   1         Configuration = SETUPDAT[2];
 213   1         return(TRUE);            // Handled by user code
 214   1      }
 215          
 216          BOOL DR_GetConfiguration(void)   // Called when a Get Configuration command is received
 217          {
 218   1         EP0BUF[0] = Configuration;
 219   1         EP0BCH = 0;
 220   1         EP0BCL = 1;
 221   1         return(TRUE);            // Handled by user code
 222   1      }
 223          
 224          BOOL DR_SetInterface(void)       // Called when a Set Interface command is received
 225          {
 226   1         AlternateSetting = SETUPDAT[2];
 227   1         return(TRUE);            // Handled by user code
 228   1      }
 229          
 230          BOOL DR_GetInterface(void)       // Called when a Set Interface command is received
 231          {
 232   1         EP0BUF[0] = AlternateSetting;
 233   1         EP0BCH = 0;
 234   1         EP0BCL = 1;
 235   1         return(TRUE);            // Handled by user code
 236   1      }
 237          
 238          BOOL DR_GetStatus(void)
 239          {
 240   1         return(TRUE);
 241   1      }
C51 COMPILER V9.51   PERIPH                                                                05/21/2013 06:46:35 PAGE 5   

 242          
 243          BOOL DR_ClearFeature(void)
 244          {
 245   1         return(TRUE);
 246   1      }
 247          
 248          BOOL DR_SetFeature(void)
 249          {
 250   1         return(TRUE);
 251   1      }
 252          
 253          BOOL DR_VendorCmnd(void)
 254          {
 255   1         return(TRUE);
 256   1      }
 257          
 258          //-----------------------------------------------------------------------------
 259          // USB Interrupt Handlers
 260          //   The following functions are called by the USB interrupt jump table.
 261          //-----------------------------------------------------------------------------
 262          
 263          // Setup Data Available Interrupt Handler
 264          void ISR_Sudav(void) interrupt 0
 265          {
 266   1         GotSUD = TRUE;            // Set flag
 267   1         EZUSB_IRQ_CLEAR();
 268   1         USBIRQ = bmSUDAV;         // Clear SUDAV IRQ
 269   1      }
 270          
 271          // Setup Token Interrupt Handler
 272          void ISR_Sutok(void) interrupt 0
 273          {
 274   1         EZUSB_IRQ_CLEAR();
 275   1         USBIRQ = bmSUTOK;         // Clear SUTOK IRQ
 276   1      }
 277          
 278          void ISR_Sof(void) interrupt 0
 279          {
 280   1         EZUSB_IRQ_CLEAR();
 281   1         USBIRQ = bmSOF;            // Clear SOF IRQ
 282   1      }
 283          
 284          void ISR_Ures(void) interrupt 0
 285          {
 286   1         // whenever we get a USB reset, we should revert to full speed mode
 287   1         pConfigDscr = pFullSpeedConfigDscr;
 288   1         ((CONFIGDSCR xdata *) pConfigDscr)->type = CONFIG_DSCR;
 289   1         pOtherConfigDscr = pHighSpeedConfigDscr;
 290   1         ((CONFIGDSCR xdata *) pOtherConfigDscr)->type = OTHERSPEED_DSCR;
 291   1         
 292   1         EZUSB_IRQ_CLEAR();
 293   1         USBIRQ = bmURES;         // Clear URES IRQ
 294   1      }
 295          
 296          void ISR_Susp(void) interrupt 0
 297          {
 298   1         Sleep = TRUE;
 299   1         EZUSB_IRQ_CLEAR();
 300   1         USBIRQ = bmSUSP;
 301   1      }
 302          
 303          void ISR_Highspeed(void) interrupt 0
C51 COMPILER V9.51   PERIPH                                                                05/21/2013 06:46:35 PAGE 6   

 304          {
 305   1         if (EZUSB_HIGHSPEED())
 306   1         {
 307   2            pConfigDscr = pHighSpeedConfigDscr;
 308   2            ((CONFIGDSCR xdata *) pConfigDscr)->type = CONFIG_DSCR;
 309   2            pOtherConfigDscr = pFullSpeedConfigDscr;
 310   2            ((CONFIGDSCR xdata *) pOtherConfigDscr)->type = OTHERSPEED_DSCR;
 311   2         }
 312   1      
 313   1         EZUSB_IRQ_CLEAR();
 314   1         USBIRQ = bmHSGRANT;
 315   1      }
 316          void ISR_Ep0ack(void) interrupt 0
 317          {
 318   1      }
 319          void ISR_Stub(void) interrupt 0
 320          {
 321   1      }
 322          void ISR_Ep0in(void) interrupt 0
 323          {
 324   1      }
 325          void ISR_Ep0out(void) interrupt 0
 326          {
 327   1      }
 328          void ISR_Ep1in(void) interrupt 0
 329          {
 330   1      }
 331          void ISR_Ep1out(void) interrupt 0
 332          {
 333   1      }
 334          void ISR_Ep2inout(void) interrupt 0
 335          {
 336   1      }
 337          void ISR_Ep4inout(void) interrupt 0
 338          {
 339   1      }
 340          void ISR_Ep6inout(void) interrupt 0
 341          {
 342   1      }
 343          void ISR_Ep8inout(void) interrupt 0
 344          {
 345   1      }
 346          void ISR_Ibn(void) interrupt 0
 347          {
 348   1      }
 349          void ISR_Ep0pingnak(void) interrupt 0
 350          {
 351   1      }
 352          void ISR_Ep1pingnak(void) interrupt 0
 353          {
 354   1      }
 355          void ISR_Ep2pingnak(void) interrupt 0
 356          {
 357   1      }
 358          void ISR_Ep4pingnak(void) interrupt 0
 359          {
 360   1      }
 361          void ISR_Ep6pingnak(void) interrupt 0
 362          {
 363   1      }
 364          void ISR_Ep8pingnak(void) interrupt 0
 365          {
C51 COMPILER V9.51   PERIPH                                                                05/21/2013 06:46:35 PAGE 7   

 366   1      }
 367          void ISR_Errorlimit(void) interrupt 0
 368          {
 369   1      }
 370          void ISR_Ep2piderror(void) interrupt 0
 371          {
 372   1      }
 373          void ISR_Ep4piderror(void) interrupt 0
 374          {
 375   1      }
 376          void ISR_Ep6piderror(void) interrupt 0
 377          {
 378   1      }
 379          void ISR_Ep8piderror(void) interrupt 0
 380          {
 381   1      }
 382          void ISR_Ep2pflag(void) interrupt 0
 383          {
 384   1      }
 385          void ISR_Ep4pflag(void) interrupt 0
 386          {
 387   1      }
 388          void ISR_Ep6pflag(void) interrupt 0
 389          {
 390   1      }
 391          void ISR_Ep8pflag(void) interrupt 0
 392          {
 393   1      }
 394          void ISR_Ep2eflag(void) interrupt 0
 395          {
 396   1      }
 397          void ISR_Ep4eflag(void) interrupt 0
 398          {
 399   1      }
 400          void ISR_Ep6eflag(void) interrupt 0
 401          {
 402   1      }
 403          void ISR_Ep8eflag(void) interrupt 0
 404          {
 405   1      }
 406          void ISR_Ep2fflag(void) interrupt 0
 407          {
 408   1      }
 409          void ISR_Ep4fflag(void) interrupt 0
 410          {
 411   1      }
 412          void ISR_Ep6fflag(void) interrupt 0
 413          {
 414   1      }
 415          void ISR_Ep8fflag(void) interrupt 0
 416          {
 417   1      }
 418          void ISR_GpifComplete(void) interrupt 0
 419          {
 420   1      }
 421          void ISR_GpifWaveform(void) interrupt 0
 422          {
 423   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    581    ----
C51 COMPILER V9.51   PERIPH                                                                05/21/2013 06:46:35 PAGE 8   

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
